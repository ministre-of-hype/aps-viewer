<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>APS Viewer — auto token</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css">
  <style>
    html, body { height:100%; margin:0; }
    #viewer { width:100%; height:100%; }
    #status {
      position:fixed; top:12px; left:12px; right:12px;
      background:#111; color:#fff; padding:10px 12px; border-radius:8px;
      font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      box-shadow:0 6px 18px rgba(0,0,0,.2); z-index:9999;
    }
    #status.ok { background:#0f5132; }
    #status.err { background:#842029; }
    code { background:rgba(255,255,255,.12); padding:0 6px; border-radius:4px; }
  </style>
</head>
<body>
  <div id="status">Готовлюсь загрузить модель…</div>
  <div id="viewer"></div>

  <script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
  <script>
    const APS_TOKEN_URL = "/api/aps-token";
    const URN_BASE64   = "dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6Y2xpbmZpdC9DRl81MDAucnZ0"; // replace with your model URN
    // Token cache for repeated use
    const tokenCache = { token: null, expTs: 0 };
    async function getFreshToken() {
      const now = Date.now();
      if (tokenCache.token && now < tokenCache.expTs) {
        return tokenCache.token;
      }
      const r = await fetch(APS_TOKEN_URL);
      if (!r.ok) {
        throw new Error("Failed to get token");
      }
      const data = await r.json();
      tokenCache.token = data.access_token;
      tokenCache.expTs = now + (Math.max(60, data.expires_in) - 60) * 1000;
      return tokenCache.token;
    }
    async function getAccessToken(callback) {
      try {
        const token = await getFreshToken();
        const secondsLeft = Math.max(300, Math.floor((tokenCache.expTs - Date.now()) / 1000));
        callback(token, secondsLeft);
      } catch (e) {
        setStatus("Error getting token: " + e.message, "err");
        console.error(e);
      }
    }

    const statusEl = document.getElementById("status");
    function setStatus(msg, cls) {
      statusEl.textContent = msg;
      statusEl.className = cls ? cls : "";
    }

    async function fetchManifest() {
      const token = await getFreshToken();
      const url = `https://developer.api.autodesk.com/modelderivative/v2/designdata/${encodeURIComponent(URN_BASE64)}/manifest`;
      const r = await fetch(url, { headers: { Authorization: "Bearer " + token } });
      if (!r.ok) throw new Error(`Manifest HTTP ${r.status}`);
      return r.json();
    }

    function initViewerAndLoad() {
      Autodesk.Viewing.Initializer({ env: "AutodeskProduction", getAccessToken }, () => {
        const viewer = new Autodesk.Viewing.GuiViewer3D(document.getElementById("viewer"));
        const started = viewer.start();
        if (started !== 0) {
          setStatus("Viewer failed to start (code " + started + ")", "err");
          return;
        }
        Autodesk.Viewing.Document.load("urn:" + URN_BASE64, (doc) => {
          const defaultGeom = doc.getRoot().getDefaultGeometry();
          viewer.loadDocumentNode(doc, defaultGeom).then(() => {
            setStatus("Модель загружена ✅", "ok");
            setTimeout(() => statusEl.remove(), 1500);
          }).catch((e) => {
            setStatus("Ошибка загрузки геометрии: см. консоль", "err");
            console.error(e);
          });
        }, (err) => {
          setStatus("Ошибка Autodesk.Viewing.Document.load — проверь URN/права", "err");
          console.error(err);
        });
      });
    }

    async function waitUntilTranslatedAndLoad() {
      try {
        const m = await fetchManifest();
        const st = (m.status || "").toLowerCase();
        if (st === "success") {
          setStatus("Перевод завершён. Загружаю модель…");
          initViewerAndLoad();
        } else if (st === "failed" || st === "timeout") {
          setStatus(`Перевод не удался: ${st}.`, "err");
          console.error("Manifest:", m);
        } else {
          const nice = st || "unknown";
          setStatus(`Статус перевода: ${nice}… Обновлю через 10 сек.`);
          setTimeout(waitUntilTranslatedAndLoad, 10000);
        }
      } catch (e) {
        setStatus("Не удалось получить манифест.", "err");
        console.error(e);
        setTimeout(waitUntilTranslatedAndLoad, 10000);
      }
    }

    waitUntilTranslatedAndLoad();
  </script>
</body>
</html>
